---
title: '[web] - Une Barre de recherche avec un filtre en React - Partie 1'
date: '2022-09-17'
tags: ['web', 'typescript', 'react']
draft: true
summary: 'Nous allons cr√©er en React une barre de recherche(avanc√©e) avec filtre.'
images: []
---

Nous allons cr√©er en React une barre de recherche avec des checkbox pour s√©lectionner
des √©l√©ments le tout accompagn√© d'un filtre _(int√©ressant n'est-ce pas ? Je sais)_.

Le rendu final peut √™tre test√© sur StackBlitz. [![Open in StackBlitz](https://developer.stackblitz.com/img/open_in_stackblitz.svg)](https://stackblitz.com/edit/searchbarwithselectandfilter?file=src/component/SearchbarWithSelectAndFilter/SearchbarWithSelectAndFilter.tsx)

## Le contexte

Dans une de mes t√¢ches dans la bo√Æte o√π je travaille, il y a un formulaire dans lequel
un administrateur devrait attribuer des fonctionnalit√©s √† des utilisateurs. Donc il peut
s√©lectionner des utilisateurs, soit taper le nom et s√©lectionner certains ou juste grouper
les utilisateurs par leur r√¥le. Donc en gros une barre de recherche avec un filtre et quelques
autres fonctionnalit√©s. Donc j'ai fait une premi√®re impl√©mentation en utilisant Material UI
que je vais d√©crire ici.

## Le probl√®me

1. `Grouper` les utilisateurs sur la base d'une `caract√©ristique quelconque`
2. `S√©lectionner` certains utilisateurs
3. `Filtrer` la liste d'utilisateurs en se basant sur les diff√©rents groupes
4. `Exposer` la liste d'utilisateurs choisis

Un peu comme sur la vid√©o suivante

<div
  style={{
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  <video width="500" height="340" loop controls autoPlay muted>
    <source
      aria-label={'Barre de recherche avec filtre'}
      about={''}
      src={'/static/images/barre_de_recherche_avec_filtre.mp4'}
      type="video/mp4"
    />
    Votre navigateur ne prend pas en charge audio ou video.
  </video>
</div>

## La solution

#### 1√®re √©tape : configuration du projet

En supposant que node est install√© sur votre machine, nous allons :

- configurer un petit projet react + typescript en utilisant vite

```shell
yarn create vite
```

- installer les d√©pendances de MUI

```shell
yarn add @mui/material @emotion/react @emotion/styled
```

```shell
yarn add @mui/icons-material
```

Ensuite un dossier `components/SearchbarWithSelectAndFilter`
et √† l'int√©rieur de ce dernier, un fichier `SearchbarWithSelectAndFilter.tsx` et `types.ts`.

- Pour les tests nous utiliserons un json d√©j√† disponible sur mon [github](https://github.com/TawalMc/SearchbarWithSelectAndFilter/tree/main/src/dummy).
  Donc vous pouvez r√©cup√©rer le dossier **_dummy_** contenant le fichier
  **_data.json_** (stock√© dans la constante `DummyData`) et **_index.ts_**.

#### 2·µâ √©tape : Les deux premiers points

1. `Grouper` les utilisateurs sur la base d'une `caract√©ristique quelconque`
2. `S√©lectionner` certains utilisateurs

Material UI fourni le component [Autocomplete](https://mui.com/material-ui/react-autocomplete/)
qui est un input permettant la recherche dans une liste d'√©l√©ments qui peuvent √™tre coch√©s.
Donc on aura (fa√Ætes les imports n√©cessaires) :

`component/SearchbarWithSelectAndFilter/SearchbarWithSelectAndFilter.tsx`

```jsx
const icon = <CheckBoxOutlineBlankIcon fontSize="small" />
const checkedIcon = <CheckBoxIcon fontSize="small" />
const SearchbarWithSelectAndFilter = () => {
  return (
    <div style={{ display: 'flex', alignItems: 'center', width: '500px' }}>
      <FormControl fullWidth>
        <Autocomplete
          fullWidth
          multiple
          disableCloseOnSelect
          limitTags={1}
          sx={{
            '& .MuiOutlinedInput-root': {
              padding: 0,
              height: 'auto',
            },
          }}
          options={DummyData}
          groupBy={(option: DummyDataType) => option.teams.title}
          getOptionLabel={(option: DummyDataType) => `${option.firstName} ${option.lastName}`}
          renderOption={(props, option, { selected }) => (
            <li {...props}>
              <Checkbox
                icon={icon}
                checkedIcon={checkedIcon}
                style={{ marginRight: 8 }}
                checked={selected}
              />
              {option.firstName} {option.lastName}
            </li>
          )}
          renderInput={(params) => (
            <TextField {...params} placeholder={'Populations'} sx={{ paddingY: 0 }} />
          )}
        />
      </FormControl>
    </div>
  )
}
```

Vous l'aurez remarqu√©, il y a le checkbox qui est rendu par le component et les deux props qui
nous int√©ressent ici sont

- `options` qui prend le tableau de donn√©es

- `groupBy` qui prend une fonction (callback) qu'elle applique √† chaque √©l√©ment de la liste pour
  g√©rer le groupage

**Bon disons la v√©rit√©, jusque-l√† on a fait que copier la doc de MUI, merci √† eux.**

#### 3·µâ √©tape : Le component de filtrage

Ici c'est juste un select box √† la MUI:

```jsx
<FormControl sx={{ minWidth: '150px', marginRight: 1 }}>
  <Select displayEmpty size="small" inputProps={{ 'aria-label': 'Without label' }}>
    <MenuItem value="">Tout</MenuItem>
    {['JSBenin', 'PythonBenin', 'RustBenin', 'PHPBenin'].map((entity) => (
      <MenuItem key={entity} value={entity}>
        {entity}
      </MenuItem>
    ))}
  </Select>
</FormControl>
```

Donc un select avec des menus items √† l'int√©rieur listant les diff√©rentes valeurs du select.

<details >
    <summary>Les deux codes ensemble ici</summary>

`SearchbarWithSelectAndFilter/SearchbarWithSelectAndFilter.tsx`

```jsx
const icon = <CheckBoxOutlineBlankIcon fontSize="small" />
const checkedIcon = <CheckBoxIcon fontSize="small" />
const SearchbarWithSelectAndFilter = () => {
  return (
    <div style={{ display: 'flex', alignItems: 'center', width: '500px' }}>
      <FormControl sx={{ minWidth: '150px', marginRight: 1 }}>
        <Select displayEmpty size="small" inputProps={{ 'aria-label': 'Without label' }}>
          <MenuItem value="">Tout</MenuItem>
          {['JSBenin', 'PythonBenin', 'RustBenin', 'PHPBenin'].map((entity) => (
            <MenuItem key={entity} value={entity}>
              {entity}
            </MenuItem>
          ))}
        </Select>
      </FormControl>
      <FormControl fullWidth>
        <Autocomplete
          fullWidth
          multiple
          disableCloseOnSelect
          limitTags={1}
          sx={{
            '& .MuiOutlinedInput-root': {
              padding: 0,
              height: 'auto',
            },
          }}
          options={DummyData}
          groupBy={(option: DummyDataType) => option.teams.title}
          getOptionLabel={(option: DummyDataType) => `${option.firstName} ${option.lastName}`}
          renderOption={(props, option, { selected }) => (
            <li {...props}>
              <Checkbox
                icon={icon}
                checkedIcon={checkedIcon}
                style={{ marginRight: 8 }}
                checked={selected}
              />
              {option.firstName} {option.lastName}
            </li>
          )}
          renderInput={(params) => (
            <TextField {...params} placeholder={'Populations'} sx={{ paddingY: 0 }} />
          )}
        />
      </FormControl>
    </div>
  )
}
```

</details>

#### 4·µâ √©tape : Le filtrage

Nous allons nous baser sur l'image suivante:

![Searchbar-with-filter-steps](/static/images/searchbarwithfilter.png)

1. **Extraire le tableau pour le dropdown**

L'utilsiateur fournit un tableau de donn√©es, on parcours celui-ci et nous r√©cup√©rons les
valeurs pour le dropdown en nous basant sur un callback que l'utilisateur renvoie.

```jsx
type SearchbarWithSelectAndFilterProps<T extends unknown> = {
    groupBy: (value: T) => string
    data: T[] | undefined
}

const SearchbarWithSelectAndFilter = (props: SearchbarWithSelectAndFilterProps) => {
   const {data, groupBy} = props;

   let itemsGroup = useMemo(() => {
   let itemsAsSet = new Set(data.map(groupBy));
   let itemsAsList: string[] = [];

    itemsAsSet.forEach((v) => {
        if (v !== undefined && v !== null) itemsAsList.push(v);
    });

    return itemsAsList;

   }, [data, groupBy]);

    return (
            {/** Le reste du code ici **/}
    )
}

// example d'utilisation
<SearchbarWithSelectAndFilter
        data={DummyData}
        groupBy={(value: DummyDataType) => value.teams.title}/>
```

En gros:

- `Set` et `groupBy`: nous parcourons le tableau de donn√©es avec un `map`, et gr√¢ce au callback (`groupBy`)
  pass√© en props, nous pouvons r√©cup√©rer la liste (les valeurs) √† fournir au dropdown. Nous le passons
  √† un `Set` pour supprimer les doublons.
- `Array`: comme le dropdown re√ßoit un tableau d'options, nous convertissons le set en un tableau (javascript array) que
  nous stockons dans _itemsGroup_.
- `useMemo`: pour m√©moriser cette liste (itemsGroup) et √©viter de refaire ces op√©rations chaque fois qu'il y a un rendu du
  component alors que la liste de
  donn√©e n'a pas chang√©.

2. **Grouper les donn√©es utilis√©es par l'autocomplete**

```js
let optionForSearch = useMemo(() => {
    let optionAsMap = new Map<string, T[]>();

    optionAsMap.set(DEFAULT_SELECT_VALUE, data);
    itemsGroup.forEach((value) => {
        optionAsMap.set(
            value,
            data.filter((v) => groupBy(v) == value)
        );
    });

    return optionAsMap;
}, [itemsGroup]);
```

En gros:

- `Map`: pour chaque √©l√©ment du tableau pr√©c√©dent (**itemsGroup**), nous cr√©ons une cl√©-valeur o√π la cl√©
  est l'√©lement provenant du tableau, et la valeur est la liste des donn√©es (provenant de **data**) filtr√©es
  en se basant sur le callback `groupBy`.

3. **Fournir les donn√©es au dropdown et √† l'autocomplete**

Nous avons d√©j√† le tableau √† passer au dropdown, les √©l√©ments regroup√©s qui seront fournis √† l'autocomplete, donc
dans cette √©tape, nous allons juste d√©finir la liste √† afficher en fonction de la cat√©gorie.

Je montre juste les parties du code concern√©es.

```jsx

{/*...some codes*/}

const [selectedItem, setSelectedItem] = useState(DEFAULT_SELECT_VALUE);

const handleSelectedItemChange = (event: SelectChangeEvent) => {
      setSelectedItem(event.target.value);
};

<Select
    {/*...*/}
    value={selectedItem}
    onChange={handleSelectedItemChange}
  >
    <MenuItem value={DEFAULT_SELECT_VALUE}>Tout</MenuItem>
    {
      itemsGroup.map(item => <MenuItem key={item} value={item}>{item}</MenuItem>)
    }
</Select>

<Autocomplete
    {/*...*/}
    options={optionForSearch.get(selectedItem) ?? []}
    groupBy={groupBy}
/>

{/*...some codes*/}
```

Ici rien de nouveau:

- `useState`: on stocke dans un state local l'item choisi dans le dropdown et comme la liste des options
  rendue par l'autocomplete est gard√©e dans un Map (avec comme cl√© les items du dropdown), nous pouvons alors
  passer la liste d'options qu'il faut √† l'autocomplete en nous basant sur la cl√©
- `groupBy`: autocomplete de MUI utilise la m√™me fonction groupBy (mais est ce que √ßa vaut la peine).
- `DEFAULT_SELECT_VALUE`: est juste une valeur par d√©faut que vous donnez au dropdown

4. **Et maintenant ?**

Bref pas grande chose ü§£. Nous avons mis ensemble des components d√©j√† cr√©√©s par MUI et nous pouvons crier un peu
partout que nous avons cr√©√© un custom component (tr√®s avanc√©): `Super!!!`. Avant de finir, abordons un dernier point:
le typage de notre nouveau component.

#### 6·µâ √©tape : Le typage de la barre de recherche avec filtre

Jetons un coup d'oeil √† ce typage o√π j'int√®gre des commentaires:

```ts
import { AutocompleteProps, CheckboxProps, FormControlProps, SelectProps } from '@mui/material'

export interface SearchbarWithSelectAndFilterProps<T extends unknown> {
  /**
   * Default placeholder used by textfield inside autocomplete
   */
  placeholder?: string

  /**
   * array of data used to make search
   */
  searchData: T[] | undefined

  /**
   * Function used as map callback to iterate over *sarchData* to get value for group field
   * @param value
   */
  groupBy: (value: T) => string

  /**
   * Function used to display custom data inside autocomplete
   * @param value
   */
  toDisplay: (value: T) => any

  /**
   * Main div container props
   */
  divProps?: ComponentPropsWithoutRef<'div'>

  /**
   * Select (used as dropdown) props
   */
  selectProps?: SelectProps<string>

  /**
   * First form control, parent of dropdown props
   */
  firstFormControlProps?: FormControlProps

  /**
   * Second form control, parent of autocomplete props
   */
  secondFormControlProps?: FormControlProps

  /**
   * Checkbox used inside autocomplete props
   */
  searchCheckboxProps?: CheckboxProps

  /**
   * Autocomplete props
   */
  autoCompleteProps?: AutocompleteProps<T, true, false, false>
}
```

Ce qu'il faut retenir ici, pour certains components utilis√©s j'ai cr√©√© une props qui contient tous les attributs
possibles afin de rendre flexible la personalisation du component. (_Un futur article sera √©crit sur comment
je d√©finis mes props pour faciliter les questions de personalisations quand plusieurs components_).

** A quoi ressemble le component ?**
Simple, nous cr√©ons un fichier MUI qui va appeler le nouveau composant cr√©√© comme suit:

src/views/MUI.tsx

```tsx
import { DummyData, DummyDataType } from '../dummy'
import SearchbarWithSelectAndFilter from '../component/SearchbarWithSelectAndFilter/SearchbarWithSelectAndFilter'

const MUI = () => {
  return (
    <div>
      <SearchbarWithSelectAndFilter
        searchData={DummyData}
        groupBy={(value: DummyDataType) => value.teams.title}
        toDisplay={(value) => `${value.firstName} ${value.lastName}`}
        autoCompleteProps={{
          options: DummyData,
          renderInput: () => <></>,
        }}
      />
    </div>
  )
}

export default MUI
```

#### 7·µâ √©tape : R√©cup√©rer les √©l√©ments s√©lectionn√©s

Apr√®s la cr√©ation du component, nous allons pouvoir r√©cup√©rer la liste des √©l√©ments (options) s√©lectionn√©s. Nous allons
afficher le nom et le r√¥le de ceux qui ont √©t√© s√©lectionn√©s, et pour cela, utiliserons deux nouveaux components,
Card et Cards que vous pouvez r√©cup√©rer sur le d√©pot ici: [Card](https://github.com/TawalMc/SearchbarWithSelectAndFilter/tree/main/src/component/Card)

En gros dans le fichier `src/component/Card/Card.tsx`

```tsx
import { DummyDataType } from '../../dummy'
import style from './Card.module.css'

export type CardProps = DummyDataType

const Card = (props: CardProps) => {
  return (
    <div className={style.card}>
      <div className={style.container}>
        <h4>
          <b>
            {props.firstName} {props?.lastName}
          </b>
        </h4>
        <p>{props.teams.title}</p>
      </div>
    </div>
  )
}

export default Card
```

puis son css `src/component/Card/Card.module.css`

```css
.card {
  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2);
  transition: 0.3s;
  width: 150px;
  height: 150px;
  border-radius: 5px;
}

.card:hover {
  box-shadow: 0 8px 16px 0 rgba(0, 0, 0, 0.2);
}

img {
  border-radius: 5px 5px 0 0;
}

.container {
  padding: 2px 16px;
}
```

et dans celui de src/component/Card/Cards.tsx

```tsx
import style from './Cards.module.css'
import { CardProps } from './Card/Card'
import Card from './Card'

export type CardsProps = {
  items: CardProps[]
}

const Cards = ({ items }: CardsProps) => {
  return (
    <div className={style.gridContainer}>
      {items.map((item, index) => (
        <Card key={index} {...item} />
      ))}
    </div>
  )
}

export default Cards
```

ainsi que son css `src/component/Card/Cards.module.css`

```css
.gridContainer {
  display: grid;
  grid-template-columns: auto auto auto;
  grid-template-rows: 80px auto 80px;
  column-gap: 20px;
  row-gap: 90px;
}
```

Dans Card, nous affichons les informations de chaque √©l√©ment s√©lectionn√© et avec Cards nous affichons une liste de Card

Pour r√©cup√©rer la liste d'√©l√©ment s√©lectionn√©, nous utiliserons un state qui sera pass√© √† l'autocompl√®te de MUI.
Et si vous aviez fait la remarque dans le typage `SearchbarWithSelectAndFilter` pr√©sent√© un peu plus haut,
il a une props `autoCompleteProps` qui h√©rite de toutes les props de Autocomplete de MUI. En effet, cette props
est pass√©e sous forme destructur√©e au composant Autocomplete utilis√© comme suit

```jsx
<Autocomplete
  fullWidth
  multiple
  disableCloseOnSelect
  limitTags={1}
  {...autoCompleteProps}
  /// d'autres props
>
  {/* d'autres contenus */}
</Autocomplete>
```

Et dans les props de Autocomplete, il y a `value` et `onChange` que nous utiliserons.
Nous allons pour cel√†, le composant MUI cr√©√© plus haut qui va utiliser le composant SearchbarWithSelectAndFilter
et affichera la liste s√©lectionn√©e.

src/views/MUI.tsx

```tsx
import { DummyData, DummyDataType } from '../dummy'
import SearchbarWithSelectAndFilter from '../component/SearchbarWithSelectAndFilter/SearchbarWithSelectAndFilter'
import Cards from '../component/Card/Cards'
import { useState } from 'react'

const MUI = () => {
  const [selectedOptions, setSelectedOptions] = useState<DummyDataType[]>([])

  // console.log(selectedOptions)

  return (
    <div>
      <SearchbarWithSelectAndFilter
        searchData={DummyData}
        groupBy={(value: DummyDataType) => value.teams.title}
        toDisplay={(value) => `${value.firstName} ${value.lastName}`}
        autoCompleteProps={{
          options: DummyData,
          renderInput: () => <></>,
          value: selectedOptions,
          onChange: (_event, value) => setSelectedOptions(value),
        }}
      />
      <br />

      <Cards items={selectedOptions} />
    </div>
  )
}

export default MUI
```

1. Nous cr√©ons un state `[selectedOptions, setSelectedOptions]` qui garde laliste s√©lection√©e
2. Nous passons aux props **value** et **onChange** de Autocomplete respectivement selectedOptions et une function
   qui met √† jour setSelectedOptions. Ceci se fait gr√¢ce √† la prop `autocompleteProps` de notre `SearchbarWithSelectAndFilter`
3. Nous passons ensuite √† `Cards` cette liste (selectedOptions).

Le r√©sultat est √† peu pr√®s ceci:

![Liste des options s√©lectionn√©es](/static/images/searchbarwithfilter_selected_options.png)

Super.

## Conclusion

Enfin, nous sommes √† la fin. J'avoue qu'elle est un peu long cette partie ü§ß. La documentation de MUI √©tant plut√¥t
bien fournie, notre travail √©tait juste d'√©crire deux fonctions qui permettent de grouper et filtrer les donn√©es pour le
dropdown et l'autocomplete.
Cela soul√®ve les probl√©matiques suivantes qui seront abord√©es dans la `partie 2`:

1. Avons nous r√©ellement besoin deux `useMemo` pour avoir la liste des √©l√©ments pour le dropdown et l'autocomplete ?
2. Comment extraire la logique du component pour qu'elle puise √™tre r√©utilis√©e aussi bien avec MUI que d'autres
   biblioth√®ques de UI comme Mantine ou Ant Design ?

Le code complet (utilisable) est disponible ici
[![Open in StackBlitz](https://developer.stackblitz.com/img/open_in_stackblitz.svg)](https://stackblitz.com/edit/searchbarwithselectandfilter?file=src/component/SearchbarWithSelectAndFilter/SearchbarWithSelectAndFilter.tsx)
et sur mon [Github](https://github.com/TawalMc/SearchbarWithSelectAndFilter).

## So

I'm sharing a few tips I use in my daily tasks and I hope you have others that you want to share with us.
you want to share with us. I'm open to tips, and my social accounts (below) are there for that.

_So can you smell what TawalMc is cooking?_

---
title: 'Arduino et FreeRTOS - Chapite 1: Les t√¢ches'
date: '2021-06-29'
tags: ['iot', 'arduino', 'freertos']
draft: false
summary: "Dans cet article nous expliquerons d'abord le concept de task en FreeRTOS et nous utiliserons ensuite le support de ce dernier sur Arduino pour cr√©er des t√¢ches(tasks) tournant sur l'ATmega"
images:
  [
    'https://hackster.imgix.net/uploads/cover_image/file/128512/ArduinoFreeRTOSLogo.png?auto=compress%2Cformat&w=900&h=675&fit=min',
  ]
---

#### _Je voudrais pr√©ciser que tout le blog et mes futurs articles (d'ici la fin de ce mois) seront en anglais et plus en fran√ßais. D√©sol√© de l'annoncer ainsi mais je pr√©senterai bient√¥t les raisons._

_Cet article n'est que la suite de l'article introductif sur FreeRTOS que j'ai publi√© r√©cemment: [Introduction √† FreeRTOS](https://tawaldevuniverse.vercel.app/blog/iot/introduction-a-freertos) et donc n'est pas pour un d√©butant en syst√®me embarqu√© mais il faut juste √™tre √† l'aise avec les microcontr√¥leurs._

![Arduino-FreeRTOS-banner](https://hackster.imgix.net/uploads/cover_image/file/128512/ArduinoFreeRTOSLogo.png?auto=compress%2Cformat&w=900&h=675&fit=min)

# C'est quoi une t√¢che dans FreeRTOS

D√©j√† pour ceux qui se demandent ce qu'est [FreeRTOS](https://www.freertos.org/), j'en ai d√©j√† parl√© dans mon pr√©c√©dent article
o√π j'y pr√©sente le RTOS(Real Time Operating System) d√©di√© aux microcontr√¥leurs qu'est FreeRTOS. Vous pouvez aller le lire
rapidement: [Introduction √† FreeRTOS](https://tawaldevuniverse.vercel.app/blog/iot/introduction-a-freertos) - _I'm waiting for you üòí._

Une t√¢che ou `task` est une action que vous faites, une commande ou une routine que vous ex√©cutez dans votre code/syst√®me.
Et comme on parle de code, en FreeRTOS une t√¢che n'est rien d'autre qu'une fonction √©crite en `C` qui ex√©cute donc une/des actions(s) et qui
ne retourne `jamais et au grand jamais` une quelconque valeur. Cette derni√®re partie est tr√®s importante:
vous faites tout ce que vous voulez mais jamais de mot cl√© `return` sinon la _5√®me grande guerre des ninjas ü§¨_.
Donc:

- Afficher dans le moniteur s√©rie (Serial monitor) la valeur retourn√©e par un capteur de temp√©rature chaque 5s est une t√¢che
- Eteindre et allumer une LED suivant une fr√©quence donn√©e est aussi une t√¢che
- ...Bref tout ce que nous avons l'habitude de faire avec notre ami Arduino.

# Caract√©ristiques d'une t√¢che

Quelques notions importantes sont √† prendre √† compte quand on veut cr√©er ou manipuler des t√¢ches (je vous l'avais d√©j√† dit, ce ne sont que des fonctions √©crites en C):

## `task's state` ou l'√©tat courant d'une t√¢che

Chaque t√¢che peut passer dans 4 √©tats diff√©rents:

- `Running State` : ce dit d'une t√¢che qui est en cours d'ex√©cution - tr√®s courante
- `Ready State` : ce dit d'une t√¢che qui n'est pas en train de s'ex√©cuter mais est pr√™te √† entrer en ex√©cution - √©tat interm√©diaire entre le `running state` et les autres √©tats
- `Blocked State` : ce dit d'une t√¢che qui n'est pas en cours d'ex√©cution (bloqu√©e) et qui attend un √©v√®nement pour d√©buter son ex√©cution - un delay par exemple fait passer une t√¢che du `running state` au `blocked state`
- `Suspended State` : ce dit d'une t√¢che qui n'est pas en cours d'ex√©cution non plus et elle n'est pas prise en compte par le gestionnaire de t√¢ches dans ce cas - tr√®s rares sont les applications qui l'utilisent

Je vous offre une image que j'ai reproduite depuis [le guide tutoriel](https://www.freertos.org/fr-content-src/uploads/2018/07/161204_Mastering_the_FreeRTOS_Real_Time_Kernel-A_Hands-On_Tutorial_Guide.pdf) et qui montre les relations entre
ces diff√©rents √©tats.

![each_task_state](/static/images/each_task_state.png)

_Les diff√©rents √©tats d'une t√¢che (j'ai volontairement supprim√© certains ajouts du manuel)._

## `task's priority` ou priorit√© d'une t√¢che

Chaque t√¢che a une priorit√© d'ex√©cution qui d√©finit si elle doit s'ex√©cuter prioritairement par rapport aux autres t√¢ches ou si d'autres t√¢ches ont `plus d'importance` donc doivent
√™tre ex√©cut√©es avant cette derni√®re. La priorit√© d'une t√¢che est d√©finie par un nombre allant de `0` √† une valeur `max` (elle est de `3` dans le cas d'Arduino) - des pr√©cisons seront fournies lors de son utilisation.

## `tick interrupt` ou interruption p√©riodique

Je vous avais dit dans l'article pr√©c√©dent que FreeRTOS simulait sur nos micronctr√¥leurs (qui n'ont qu'un seul coeur) le `multitasking`. En fait pour y arriver,
il proc√®de √† des interruptions p√©riodiques (`tick interrupt` ou `periodic interrupt`) o√π il d√©cide de la prochaine t√¢che √† ex√©cuter ce qui fait croire que plusieurs t√¢ches sont en train de s'ex√©cuter au m√™me moment.
Du manuel on peut lire ceci

```
The number of tick interrupts that have occurred since the FreeRTOS
application started is called the tick count. The tick count is used as a
measure of time.
```

En gros il y a des interruptions p√©riodiques qui surviennent depuis l'ex√©cution de votre code tournant FreeRTOS et le nombre d'interruptions est
utilis√© comme √©chelle de mesure du temps. Vous allez remarquer par la suite que pour d√©finir nos `delay` nous convertirons d'abord notre temps de pause
en `tick period`. Ces interruptions se r√©p√®tent chaque fois apr√®s un temps donn√© appel√© `time slice`.
En r√©alit√© nos t√¢ches s'ex√©cutent durant ce `time slice` (valeur d√©finie dans les fichiers de configurations de `FreeRTOSConfig.h` en Hz qu'on peut rapporter en millisecondes) et √† la fin de ce temps
le `tick interrupt` survient et le gestionnaire de t√¢ches d√©finit alors la prochaine t√¢che √† ex√©cuter.

_Waoh je vous assure quand je r√©digeais l'article et j'ai pu expliquer avec des mots la notion de `tick interrupt`, je me suis senti comme Thor avec son marteau devant les elfes, trop coool._

#### _Pour la suite j'√©cris le code en anglais mais les commentaires sont en fran√ßais, sorry_

# Halte! Tr√™ve de bavardages, et si on cr√©ait des tasks

Pour cr√©er une t√¢che, il faut respecter la signature suivante

```c
/**
*   prototype de la fonction qui repr√©sente notre t√¢che (elle ne renvoie rien);
*   le param√®tre pvParameters sera vu dans un prochain article
**/
void theNameOfTaskFunction( void *pvParameters );
```

et utiliser la fonction d√©finie par FreeRTOS pour cr√©er les t√¢ches

```c
BaseType_t xTaskCreate( TaskFunction_t pvTaskCode,      /// pointeur sur la fonction-t√¢che: theNameOfTaskFunction dans notre cas
                        const char * const pcName,      /// cha√Æne de carcat√®res repr√©sentant le nom de la fonction pour le debuggage uniquement (16 caract√®res maxi si Arduino)
                        uint16_t usStackDepth,          /// l'espace-m√©moire occup√© par cette t√¢che, je vous avais parl√© d'allocation de la m√©moire par FreeRTOS pour l'ex√©cution de t√¢ches
                        void *pvParameters,             /// le m√™me param√®tre pass√© √† la fonction-t√¢che
                        UBaseType_t uxPriority,         /// la priorit√© d'une t√¢che: [0;3]
                        TaskHandle_t *pxCreatedTask );  /// un pointeur sur la t√¢che pour des utilisations ult√©rieures, par exemple la supprim√©e.
```

`BaseType_t`, `TaskFunction_t`, `UBaseType_t`, `TaskHandle_t`, `...` sont juste des types d√©finis par FreeRTOS reposant sur les types primitifs disponibles
en C et qui peuvent varier selon l'architecture (8bits, 16bits, ...) et qui leur permet d'avoir une consistence dans leur code. _Don't be afraid üòà_

## Et Arduino dans le lot

Bien nous allons cr√©er deux t√¢ches simples

- Afficher un texte "Hi Embedded World!" chaque seconde dans le Serial monitor d'Arduino - `t√¢che 1`
- Clignoter une LED chaque 3s - `t√¢che 2`

### Installation de FreeRTOS sous Arduino

Elle est tr√®s simple:

1. Dans le gestionnaire de librairies (libraries manager) sous l'onglet outils (tools) de l'IDE Arduino
2. Chercher `FreeRTOS` et installer cette derni√®re (le premier r√©sultat de la recherche)

Nous allons tester le code suivant

```c
#include <Arduino_FreeRTOS.h>

void TaskPrintText  (void *pvParameters);   /// prototype de la t√¢che 1 affichant: Hi Embedded World!
void TaskBlink      (void *pvParameters);   /// prototype de la t√¢che 2 faisant clignoter la led LED_BUILTIN (led 13 qui se trouve sur la carte Arduino)

void setup()
{
  Serial.begin(9600);
  while (!Serial)
  {
    ;
  }

  /// T√¢che 1
  xTaskCreate(
    TaskPrintText,
    "PrintText",    /// vous pouvez donner n'importe quel nom, FreeRTOS ne l'utilise pas. C'est juste pour le debuggage
    128,            /// taille de l'allocation de la m√©moire que la t√¢che va utiliser, je la laise aussi √† 128
    NULL,           /// notre fonction ne prend rien en param√®tre donc ici on passe juste un NULL
    1,              /// t√¢che de priorit√© 1. Une t√¢che de priorit√© √©lev√©e sera toujours ex√©cut√©e au d√©triment des t√¢ches de priorit√©s √† moins de passer √† un √©tat bloquant
    NULL);          /// nous ne pr√©voyons pas utiliser un pointeur sur cette t√¢che pour des utilisations ult√©rieures donc on passe juste NULL

  /// T√¢che 2
  xTaskCreate(
    TaskBlink,
    "Blink",
    128,
    NULL,
    1,              /// cette t√¢che aussi a la m√™me priorit√© que la pr√©c√©dente pour √™tre s√ªr qu'elle s'ex√©cutera
    NULL);
}

void loop()
{
  /// nous ne mettons rien ici
}

void TaskPrintText(void *pvParameters)
{
  (void)pvParameters;

    /// une boucle infinie comme le loop habituel, mais ne comportant pas de return
  for (;;)
  {
    Serial.println("Hi Embedded World!");
  }
}

void TaskBlink(void *pvParameters)
{
  (void)pvParameters;

  pinMode(LED_BUILTIN, OUTPUT);

    /// une boucle infinie comme le loop habituel, mais ne comportant pas de return
  while (1)
  {
    digitalWrite(LED_BUILTIN, HIGH);
    vTaskDelay(1000 / portTICK_PERIOD_MS); /// delay de 1s: conversion de 1000ms en tick period dont j'avais parl√©
    digitalWrite(LED_BUILTIN, LOW);
    vTaskDelay(1000 / portTICK_PERIOD_MS); /// delay de 1s: conversion de 1000ms en tick period dont j'avais parl√©
  }
}
```

# Alors

Voil√† on a fait un tour de la notion de t√¢che et de quelques concepts qui lui sont li√©s. J'avoue que cet article est un peu long, et nous n'avions pas
vraiment test√© les diff√©rentes possibilit√©s offertes par FreeRTOS √† travers les t√¢ches. Mais je vous le promets, les prochains articles (au moins 2) porteront
uniquement sur les t√¢ches et leur utilisation avec Arduino: comment communiquer entre deux t√¢ches, des cas d'utilisation du rtos avec le module
rfid ou clock...Je vous pr√©pare du lourd quand m√™me.N'h√©sitez pas √† me faire des retours dans mon mail ou sur mon Twitter ou Linkedin dont les r√©f√©rences sont en dessous
ou simplement cliquer sur `Partager ‚Ä¢`.

Et sur ce: _can you smell what TawalMc is cooking?_

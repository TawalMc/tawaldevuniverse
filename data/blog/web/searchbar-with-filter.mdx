---
title: '[web] - Une Barre de recherche avec un filtre en React - Partie 1: MUI'
date: '2022-09-17'
tags: ['web', 'typescript', 'react']
draft: false
summary: 'Nous allons cr√©er en React une barre de recherche(avanc√©e) avec filtre.'
images: []
---

Nous allons cr√©er en React une barre de recherche avec des checkbox pour s√©lectionner
des √©l√©ments le tout accompagn√© d'un filtre _(int√©ressant n'est-ce pas ? Je sais)_.

Le rendu final peut √™tre test√© sur StackBlitz. [![Open in StackBlitz](https://developer.stackblitz.com/img/open_in_stackblitz.svg)](https://stackblitz.com/github/TawalMc/SearchbarWithSelectbox)

## Le contexte

Dans une de mes t√¢ches dans la bo√Æte o√π je travaille, il y a un formulaire dans lequel
un administrateur devrait attribuer des fonctionnalit√©s √† des utilisateurs. Donc il peut
s√©lectionner des utilisateurs, soit taper le nom et s√©lectionner certains ou juste grouper
les utilisateurs par leur r√¥le. Donc en gros une barre de recherche avec un filtre et quelques
autres fonctionnalit√©s. Donc j'ai fait une premi√®re impl√©mentation en utilisant Material UI
que je vais d√©crire ici.

## Le probl√®me

1. `Grouper` les utilisateurs sur la base d'une `caract√©ristique quelconque`
2. `S√©lectionner` certains utilisateurs
3. `Filtrer` la liste d'utilisateurs en se basant sur les diff√©rents groupes
4. `Exposer` la liste d'utilisateurs choisis

Un peu comme sur la vid√©o suivante

<div
  style={{
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  <video width="500" height="340" loop controls autoPlay muted>
    <source
      aria-label={'Barre de recherche avec filtre'}
      about={''}
      src={'/static/images/barre_de_recherche_avec_filtre.mp4'}
      type="video/mp4"
    />
    Votre navigateur ne prend pas en charge audio ou video.
  </video>
</div>

## La solution

#### 1√®re √©tape : configuration du projet

En supposant que node est install√© sur votre machine, nous allons :

- configurer un petit projet react + typescript en utilisant vite

```shell
yarn create vite
```

- installer les d√©pendances de MUI

```shell
yarn add @mui/material @emotion/react @emotion/styled
```

```shell
yarn add @mui/icons-material
```

Ensuite un dossier `components/SearchbarWithSelectboxAndAutocompletionInMUI`
et √† l'int√©rieur de ce dernier, un fichier `index.tsx` et `types.ts`.

- Pour les tests
  Nous utiliserons un json d√©j√† disponible sur mon [github](https://github.com/TawalMc/SearchbarWithSelectbox/tree/main/src/dummy).
  Donc vous pouvez r√©cup√©rer le dossier **_dummy_** contenant le fichier
  **_data.json_** (stock√© dans la constante `DummyData`) et **_index.ts_**.

#### 2·µâ √©tape : Les deux premiers points

1. `Grouper` les utilisateurs sur la base d'une `caract√©ristique quelconque`
2. `S√©lectionner` certains utilisateurs

Material UI fourni le component [Autocomplete](https://mui.com/material-ui/react-autocomplete/)
qui est un input permettant la recherche dans une liste d'√©l√©ments qui peuvent √™tre coch√©s.
Donc on aura (fa√Ætes les imports n√©cessaires) :

`SearchbarWithSelectboxAndAutocompletionInMUI/index.tsx`

```jsx
const icon = <CheckBoxOutlineBlankIcon fontSize="small" />
const checkedIcon = <CheckBoxIcon fontSize="small" />
const SearchbarSelectCheckbox = () => {
  return (
    <div style={{ display: 'flex', alignItems: 'center', width: '500px' }}>
      <FormControl fullWidth>
        <Autocomplete
          fullWidth
          multiple
          disableCloseOnSelect
          limitTags={1}
          sx={{
            '& .MuiOutlinedInput-root': {
              padding: 0,
              height: 'auto',
            },
          }}
          options={DummyData}
          groupBy={(option: DummyDataType) => option.teams.title}
          getOptionLabel={(option: DummyDataType) => `${option.firstName} ${option.lastName}`}
          renderOption={(props, option, { selected }) => (
            <li {...props}>
              <Checkbox
                icon={icon}
                checkedIcon={checkedIcon}
                style={{ marginRight: 8 }}
                checked={selected}
              />
              {option.firstName} {option.lastName}
            </li>
          )}
          renderInput={(params) => (
            <TextField {...params} placeholder={'Populations'} sx={{ paddingY: 0 }} />
          )}
        />
      </FormControl>
    </div>
  )
}
```

Vous l'aurez remarqu√©, il y a le checkbox qui est rendu par le component et les deux props qui
nous int√©ressent ici sont

- `options` qui prend le tableau de donn√©es

- `groupBy` qui prend une fonction (callback) qu'elle applique √† chaque √©l√©ment de la liste pour
  g√©rer le groupage

**Bon disons la v√©rit√©, jusque-l√† on a fait que copier la doc de MUI, merci √† eux.**

#### 3·µâ √©tape : Le component de filtrage

Ici c'est juste un select box √† la MUI:

```jsx
<FormControl sx={{ minWidth: '150px', marginRight: 1 }}>
  <Select displayEmpty size="small" inputProps={{ 'aria-label': 'Without label' }}>
    <MenuItem value="">Tout</MenuItem>
    {['JSBenin', 'PythonBenin', 'RustBenin', 'PHPBenin'].map((entity) => (
      <MenuItem key={entity} value={entity}>
        {entity}
      </MenuItem>
    ))}
  </Select>
</FormControl>
```

Donc un select avec des menus items √† l'int√©rieur lisant les diff√©rentes valeurs du select.

<details >
    <summary>Les deux codes ensemble ici</summary>

`SearchbarWithSelectboxAndAutocompletionInMUI/index.tsx`

```jsx
const icon = <CheckBoxOutlineBlankIcon fontSize="small" />
const checkedIcon = <CheckBoxIcon fontSize="small" />
const SearchbarSelectCheckbox = () => {
  return (
    <div style={{ display: 'flex', alignItems: 'center', width: '500px' }}>
      <FormControl sx={{ minWidth: '150px', marginRight: 1 }}>
        <Select displayEmpty size="small" inputProps={{ 'aria-label': 'Without label' }}>
          <MenuItem value="">Tout</MenuItem>
          {['JSBenin', 'PythonBenin', 'RustBenin', 'PHPBenin'].map((entity) => (
            <MenuItem key={entity} value={entity}>
              {entity}
            </MenuItem>
          ))}
        </Select>
      </FormControl>
      <FormControl fullWidth>
        <Autocomplete
          fullWidth
          multiple
          disableCloseOnSelect
          limitTags={1}
          sx={{
            '& .MuiOutlinedInput-root': {
              padding: 0,
              height: 'auto',
            },
          }}
          options={DummyData}
          groupBy={(option: DummyDataType) => option.teams.title}
          getOptionLabel={(option: DummyDataType) => `${option.firstName} ${option.lastName}`}
          renderOption={(props, option, { selected }) => (
            <li {...props}>
              <Checkbox
                icon={icon}
                checkedIcon={checkedIcon}
                style={{ marginRight: 8 }}
                checked={selected}
              />
              {option.firstName} {option.lastName}
            </li>
          )}
          renderInput={(params) => (
            <TextField {...params} placeholder={'Populations'} sx={{ paddingY: 0 }} />
          )}
        />
      </FormControl>
    </div>
  )
}
```

</details>

#### 4·µâ √©tape : Le filtrage

Nous allons nous baser sur l'image suivante:

![Searchbar-with-filter-steps](/static/images/searchbarwithfilter.png)

1. **Extraire le tableau pour le dropdown**

L'utilsiateur fournit un tableau de donn√©es, on parcours celui-ci et nous r√©cup√©rons les
valeurs pour le dropdown en nous basant sur un callback que l'utilisateur renvoie.

```jsx
type SearchbarSelectCheckboxType<T extends unknown> = {
    groupBy: (value: T) => string
    data: T[] | undefined
}

const SearchbarSelectCheckbox = (props: SearchbarSelectCheckboxType) => {
   const {data, groupBy} = props;

   let itemsGroup = useMemo(() => {
   let itemsAsSet = new Set(data.map(groupBy));
   let itemsAsList: string[] = [];

    itemsAsSet.forEach((v) => {
        if (v !== undefined && v !== null) itemsAsList.push(v);
    });

    return itemsAsList;

   }, [data, groupBy]);

    return (
            {/** Le reste du code ici **/}
    )
}

// example d'utilisation
<SearchbarSelectCheckbox
        data={DummyData}
        groupBy={(value: DummyDataType) => value.teams.title}/>
```

En gros:

- `Set` et `groupBy`: nous parcourons le tableau de donn√©es avec un `map`, et gr√¢ce au callback (`ÃÄgroupBy`)
  pass√© en props, nous pouvons r√©cup√©rer la liste (les valeurs) √† fournir au dropdown. Nous le passons
  √† un `Set` pour supprimer les doublons.
- `Array`: comme le dropdown re√ßoit un tableau d'options, nous convertissons le set en un tableau (javascript array) que
  nous stockons dans _itemsGroup_.
- `useMemo`: pour m√©moriser cette liste (itemsGroup) et √©viter de refaire ces op√©rations chaque fois qu'il a un rendu du
  component alors que la liste de
  donn√©e n'a pas chang√©.

2. **Grouper les donn√©es utilis√©es par le autocomplete**

```jsx
let optionForSearch = useMemo(() => {
    let optionAsMap = new Map<string, T[]>();

    optionAsMap.set(DEFAULT_SELECT_VALUE, data);
    itemsGroup.forEach((value) => {
        optionAsMap.set(
            value,
            data.filter((v) => groupBy(v) == value)
        );
    });

    return optionAsMap;
}, [itemsGroup]);
```

En gros:

- `Map`: pour chaque √©l√©ment du tableau pr√©c√©dent (**itemsGroup**), nous cr√©ons une cl√©-valeur o√π la cl√©
  est l'√©lement provenant du tableau, et la valeur est la liste des donn√©es (provenant de **data**) filtr√©es
  en se basant sur le callback `groupBy`.

3. **Fournir les donn√©es au dropdown et √† l'autocomplete**

Nous avons d√©j√† le tableau √† passer au dropdown, les √©l√©ments regroup√©s qui seront fournis √† l'autocomplete, donc
dans cette √©tape, nous allons juste d√©finir la liste √† afficher en fonction de la cat√©gorie.

Je montre juste les parties du code concern√©es.

```jsx

{/*...some codes*/}

const [selectedItem, setSelectedItem] = useState(DEFAULT_SELECT_VALUE);

const handleSelectedItemChange = (event: SelectChangeEvent) => {
      setSelectedItem(event.target.value);
};

<Select
    {/*...*/}
    value={selectedItem}
    onChange={handleSelectedItemChange}
  >
    <MenuItem value={DEFAULT_SELECT_VALUE}>Tout</MenuItem>
    {
      itemsGroup.map(item => <MenuItem key={item} value={item}>{item}</MenuItem>)
    }
</Select>

<Autocomplete
    {/*...*/}
    options={optionForSearch.get(selectedItem) ?? []}
    groupBy={groupBy}
/>

{/*...some codes*/}
```

Ici rien de nouveau:

- `useState`: on stocke dans un state local l'item choisi dans le dropdown et comme la liste des options
  rendue par l'autocomplete est gard√©e dans un Map (avec comme cl√© les items du dropdown), nous pouvons alors
  passer la liste d'options qu'il faut √† l'autocomplete en nous basant sur la cl√©
- `ÃÄgroupBy`: autocomplete de MUI utilise la m√™me fonction groupBy (mais est ce que √ßa vaut la peine).
- `DEFAULT_SELECT_VALUE`: est juste une valeur par d√©faut que vous donnez au dropdown

4. **Et maintenant ?**
   Le code complet (utilisable)

Bref pas grande chose üòä. Nous avons mis ensemble des components d√©j√† cr√©√©s par MUI et nous pouvons crier un peu
partout que nous avons cr√©√© un custom component (tr√®s avanc√©): `Super!!!`.

## So

I'm sharing a few tips I use in my daily tasks and I hope you have others that you want to share with us.
you want to share with us. I'm open to tips, and my social accounts (below) are there for that.

_So can you smell what TawalMc is cooking?_

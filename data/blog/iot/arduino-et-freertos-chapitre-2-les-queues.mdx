---
title: 'Arduino et FreeRTOS - Chapite 2: Les queues'
date: '2021-07-12'
tags: ['iot', 'arduino', 'freertos']
draft: false
summary: 'Dans cet article nous parlerons de la transmission de donn√©e/informations entre les t√¢ches: Les Queues'
images:
  [
    'https://hackster.imgix.net/uploads/cover_image/file/128512/ArduinoFreeRTOSLogo.png?auto=compress%2Cformat&w=900&h=675&fit=min',
  ]
---

#### _Je voudrais pr√©ciser que tout le blog et mes futurs articles (d'ici la fin de ce mois) seront en anglais et plus en fran√ßais. D√©sol√© de l'annoncer ainsi mais je pr√©senterai bient√¥t les raisons._

_Cet article n'est que la suite de l'article sur l'utilisation des t√¢ches de FreeRTOS en Arduino que j'ai publi√© r√©cemment et donc n'est pas pour un d√©butant en syst√®me embarqu√© mais il faut juste √™tre √† l'aise avec les microcontr√¥leurs._

![Arduino and FreeRTOS banner](https://hackster.imgix.net/uploads/cover_image/file/128512/ArduinoFreeRTOSLogo.png?auto=compress%2Cformat&w=900&h=675&fit=min)

Des deux articles pr√©c√©dents vous allez remarquer que pour transmettre des informations entre les t√¢ches nous utilisons
nos bonnes vieilles variables globales. Donc quand une t√¢che met √† jour une variable globale, les autres t√¢ches
qui utilisent cette variable auront les `nouvelles valeurs de cette variable`. S√©rieusement ? Bon disons pas tout √† fait.

# Et quel est le probl√®me alors ?

En fait:

- Si une t√¢che de priorit√© √©lev√©e modifie plusieurs fois une variable alors une t√¢che de priorit√© faible doit
  dans la plus part des cas attendre que la t√¢che de priorit√© √©lev√©e passe dans un √©tat bloquant pour pouvoir ainsi
  s'ex√©cuter et donc acc√©der √† la nouvelle valeur de la variable. Mais dans ce cas, a t-elle vraiment acc√®s √† toutes
  les valeurs de la variable ?
- Etant donn√© qu'une t√¢che s'ex√©cute un nombre de fois donn√© suivant le `tick period` cela implique aussi que si cette
  variable est modifi√©e plusieurs fois, m√™me une t√¢che de priorit√© √©gale n'aura pas automatiquement acc√®s aux nouvelles
  valeurs de cette variable.

L'id√©al serait alors d'envoyer explicitement les nouvelles valeurs √† une t√¢che ou notifi√©e cette derni√®re de la disponibilit√©
de nouvelles valeurs de la variable √† chaque moment o√π il le faut. Bien cela nous am√®ne vers notre sujet du jour: `Les queues`.

# Les queues: nouveau concept, nouveau discours

Une queue est un m√©canisme mise en place par FreeRTOS pour r√©soudre les probl√®mes √©voqu√©s plus haut _(√ßa on l'a compris üòé)_.
En r√©alit√© une `queue` comme son nom l'indique repr√©sente un syst√®me FIFO (First In FIrst Out) o√π des donn√©es (variables)
sont envoy√©es depuis une ou plusieurs t√¢ches vers une ou plusieurs autres t√¢ches. C'est disons un canal de communication entre
les t√¢ches o√π on s'assure que l'ordre d'envoi des donn√©es est respect√©e √† la r√©ception par les t√¢ches. Donc √† un instant t
nous sommes s√ªrs que la valeur courante de la variable est envoy√©e dans la `queue` pour √™tre r√©cup√©r√©e par la t√¢che(fonction)
qu'il faut. Jetez un coup d'oeil √† l'image que j'ai tir√©e de la documentation:

![Tasks and queue](/static/images/tasks_queue.png)

## Diff√©rents types d'impl√©mentations des queues

Il y a deux mani√®res principalement d'impl√©menter les queues:

- queue par copie: les donn√©es sont copi√©es dans la queue
- queue par r√©f√©rence: chaque donn√©e a un pointeur qui est pass√© √† la queue

Ci-dessous le prototype de la fonction de cr√©ation d'une queue:

```C
QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize );
```

1. uxQueueLength: le `nombre maximal d'√©l√©ments/donn√©es` que la queue √† un instant t peut contenir
2. uxItemSize: la taille en `byte` de chaque √©l√©ment √† stocker dans la queue
3. la valeur retourn√©e doit √™tre stock√©e: NULL si la queue n'a pas √©t√© cr√©√©e (insuffisance de m√©moire) et une valeur non NULL indique que la queue a vraiment √©t√© cr√©√©e et on peut utiliser le retour pour acc√©der √† la queue.

Pour envoyer des donn√©es dans la queue:

```C
BaseType_t xQueueSend( QueueHandle_t xQueue,          // the queue used to send data
                        const void * pvItemToQueue,   // pointer to data to send
                        TickType_t xTicksToWait );    // amount of time to wait in blocked state for availability of space in queue
```

Il y a d'autres fonctions d'envoi de donn√©es dans une queue comme `xQueueSendToFront` ou `xQueueSendToBack` que vous
pouvez explorer.

Pour re√ßevoir des donn√©es de la queue:

```C
BaseType_t xQueueReceive( QueueHandle_t xQueue,       // the queue used to send data
                          void * const pvBuffer,      // pointer to data to send
                          TickType_t xTicksToWait );  // amount of time to wait in blocked state for availability of data in queue
```

## Et si on faisait un essai?

Nous allons utiliser le c√¢blage de [l'article pr√©cedent](https://tawaldevuniverse.vercel.app/blog/iot/arduino-et-freertos-chapitre1-les-taches-suites) sur les t√¢ches:
RFID-RC522 + Serial Monitor + LED (3 t√¢ches). Donc:

- Le module RC-522 identifie l'ID des cartes RFID/badges `(t√¢che 1)` et l'envoie √† une autre t√¢che qui l'affiche dans le Serial monitor `(t√¢che 2)`
- La LED sera en train de clignoter `(t√¢che 3)`

La LED est reli√©e au pin A0 (ne pas oublier la r√©sistance ohmique) et le c√¢blage du module RC-522 est le suivant

| RFID | Arduino |
| ---- | ------- |
| 3.3V | 3.3V    |
| RST  | D9      |
| GND  | GND     |
| RQ   | -       |
| MISO | D12     |
| MOSI | D11     |
| SCK  | D13     |
| SDA  | D10     |

Ainsi on a:

1. Nos initialisations et includes

```C
#include <Arduino.h>
#include <Arduino_FreeRTOS.h>  // Need for FreeRTOS with Arduino
#include <queue.h>             // Need to use FreeRTOS queue
#include <MFRC522.h>           // Need to use RFID utilities
#include <SPI.h>               // RFID communicate with Arduino via SPI

const uint8_t ss = 10;
const uint8_t rst = 9;

MFRC522 rfid(ss, rst);

const uint8_t led = A0;  // led pin
```

2. Le prorotype de nos t√¢ches

```C
////////////////////////////////////
///////// Task prototype ///////////
////////////////////////////////////
void TaskRfidRead(void *pvParameters);     // task to read rfid
void TaskBlinking(void *pvParameters);     // task to blink led
void TaskSerialPrint(void *pvParameters);  // task to print in serial
```

3. D√©claration de la variable qui contiendra la queue

```C
////////////////////////////////////
//////// Queue /////////////////////
////////////////////////////////////
QueueHandle_t stringQueuePrint;  // our queue to handle rfid string
```

4. Quelques fonctions utilis√©es lors de la lecture des ID

```C
////////////////////////////////////
/////// Utilities functions ////////
////////////////////////////////////
String getRfidID(byte *buffer,
                 byte bufferSize);  // to format and return the rfid id

```

5. Le void setup

```C
void setup() {
  // put your setup code here, to run once:

  Serial.begin(9600);

  SPI.begin();      // Init SPI bus
  rfid.PCD_Init();  // Init MFRC522

  // queue creation. We'll hold queue return value to used it after
  // (2)
  stringQueuePrint = xQueueCreate(
      10,             // queue length - we can hold 10 values at one time
      sizeof(String)  // each element of queue has sizeof(String) byte size
  );

  // tasks creation.
  // We'll create them if only queue is created
  // We can verify if task has been successfully created so we can log some
  // messages

  // (2)
  if (stringQueuePrint != NULL) {
    Serial.println("Queue succesfully created");

    if (xTaskCreate(TaskRfidRead, "rfid-reader", 128, NULL, 1, NULL) ==
        pdFAIL) {
      Serial.println("cannot create task: rfid-reader");
    }

    if (xTaskCreate(TaskSerialPrint, "print", 128, NULL, 1, NULL) == pdFAIL) {
      Serial.println("cannot create task: print");
    }
  }

  // blinking task is independant to other tasks
  // (3)
  if (xTaskCreate(TaskBlinking, "blinking", 128, NULL, 1, NULL) == pdFAIL) {
    Serial.println("cannot create task: blinking");
  }

  vTaskStartScheduler();
}
```

Remarquez ici:

- `(1)`: je r√©cup√®re dans la variable un pointeur sur la queue
- `(2)`: on s'assure que la queue a √©t√© vaiment cr√©√©e afin de cr√©er ou pas les t√¢ches qui l'utilisent
- `(3)`: notre fonction de blinking est ind√©pendante des deux autres

6. Comme d'habitude rien dans le void loop, le pauvre

```C
void loop() {
  // put your main code here, to run repeatedly: NOTHING HERE
}
```

7. La fonction de lecture de l'ID de la carte RFID

```C
// task to read rfid
void TaskRfidRead(void *pvParameters) {
  (void)pvParameters;

  String rfidID = "";
  String pastRfidID = "";
  uint8_t count = 0;

  for (;;) {
    if (rfid.PICC_IsNewCardPresent() && rfid.PICC_ReadCardSerial()) {
      rfidID = getRfidID(rfid.uid.uidByte, rfid.uid.size);

      if (pastRfidID == rfidID) {
        count += 1;
      } else {
        count = 0;
      }

      if ( (count % 50) == 0) {
        BaseType_t statusSend = xQueueSend(stringQueuePrint, &rfidID, 0);

        if( statusSend != pdPASS ) {
          Serial.println("rfid-reader cannont send data to queue");
        }

        pastRfidID = rfidID;
        count = 0;
      }
    }
  }
}
```

Vous remarquerez ici que j'ai ajout√© quelques lignes de codes et une condition sur le nombre de fois
on lit l'ID: en fait sans ce bout de code, la carte rfid renvoie √† la milliseconde le m√™me ID le temps
que la carte ne soit pr√©sent√©e donc je m'assure d'un nombre de lecture donn√© (0 ou 50) √† chaque fois avant
d'envoier l'ID √† la t√¢che concern√©e. Un message est renvoy√©e si l'envoi √©choue.

8. Celle de l'affichage de l'ID

```C
// task to print
void TaskSerialPrint(void *pvParameters) {
  (void)pvParameters;

  String rfidID = "";

  for (;;) {
    if (xQueueReceive(stringQueuePrint, &rfidID, 0) == pdPASS) {
      Serial.print("rfidID: "); Serial.println(rfidID);
    }
  }
}
```

Elle est toute simple: affiche l'ID si elle est disponible dans la queue.

9. Et l'impl√©mentation de la fonction de traitement de l'ID

```C
////////////////////////////////////
/////// Utilities functions ////////
////////////////////////////////////

String getRfidID(byte *buffer, byte bufferSize) {
  String uidRead = "";

  for (byte i = 0; i < bufferSize; i++) {
    uidRead += buffer[i] < 0x10 ? " 0" : " ";
    uidRead += String(buffer[i], HEX);
  }
  uidRead.toUpperCase();

  return uidRead;
}
```

10. Run the code...

Ok compilez et admirez!

#### NB: Il y a un petit probl√®me pour ceux qui auront compil√© le code, ils le remarqueront alors c'est lequel? On en discute sur mon twitter...

# Ensuite

Nous venons d'explorer un aspect des queues, il reste encore d'autres mani√®res de les utiliser que nous d√©couvrirons
peut √™tre dans les prochains TP comme:

- Envoyer des structures √† la queue donc diff√©rents type de donn√©es - (pointeur sur stucture)
- Envoyer des donn√©es dans plusieurs queues et en recevoir de diff√©rentes queues...

C'est toujours interessant d'explorer des documentations et de nouvelles technologies et c'est surtout interessant de
partager nos d√©couvertes et de les appliquer. Pour la suite je pense √† parler d'un autre aspect de FreeRTOS ou
de r√©aliser un projet utilisant tout ce que nous venons d'apprendre sur le syst√®me et permettant de d√©couvrir d'autres
notions. Je vous pr√©pare du lourd pour la prochaine fois. N'h√©sitez pas √† me faire des retours dans mon mail ou sur mon Twitter ou Linkedin dont les r√©f√©rences sont en dessous
ou simplement cliquer sur `Partager sur Twitter ‚Ä¢ LinkedIn`.

Et sur ce: _can you smell what TawalMc is cooking?_

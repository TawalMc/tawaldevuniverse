---
title: 'Arduino et FreeRTOS - Chapite 1: Les t√¢ches (suites)'
date: '2021-07-07'
tags: ['iot', 'arduino', 'freertos']
draft: false
summary: "Dans cet article nous irons un peu plus en profondeur en ce qui concerne l'utilisation des t√¢ches de FreeRTOS en Arduino"
images:
  [
    'https://hackster.imgix.net/uploads/cover_image/file/128512/ArduinoFreeRTOSLogo.png?auto=compress%2Cformat&w=900&h=675&fit=min',
  ]
---

_Cet article n'est que la suite de l'article sur l'utilisation des t√¢ches de FreeRTOS en Arduino que j'ai publi√© r√©cemment: [Arduino et FreeRTOS - Chapite 1: Les t√¢ches](https://tawaldevuniverse.vercel.app/blog/iot/arduino-et-freertos-chapitre1-les-taches) et donc n'est pas pour un d√©butant en syst√®me embarqu√© mais il faut juste √™tre √† l'aise avec les microcontr√¥leurs._

![Arduino-FreeRTOS-banner](https://hackster.imgix.net/uploads/cover_image/file/128512/ArduinoFreeRTOSLogo.png?auto=compress%2Cformat&w=900&h=675&fit=min)

# Notre objectif

Nous allons nous baser sur un circuit tr√®s simple mais en mettant l'accent sur le fonctionnement et l'utilisation des t√¢ches en FreeRTOS üòé.

## Test 1: RFID-RC522 et Serial Monitor + LED (2 t√¢ches)

Dans celui ci:

- Le module RC-522 identifie l'ID des cartes RFID/badges et l'affiche dans le Serial monitor `t√¢che 1` - _(on va les d√©partager par la suite pour en faire deux t√¢ches distinctes üòà)_
- La LED sera en train de clignoter `t√¢che 2`

La LED est reli√©e au pin A0 (ne pas oublier la r√©sistance ohmique) et le c√¢blage du module RC-522 est le suivant

| RFID | Arduino |
| ---- | ------- |
| 3.3V | 3.3V    |
| RST  | D9      |
| GND  | GND     |
| RQ   | -       |
| MISO | D12     |
| MOSI | D11     |
| SCK  | D13     |
| SDA  | D10     |

Vou pouvez jeter un coup d'oeil rapide sur l'image suivante

![Schematic_freertos_rfid_led_2021-07-06.svg](/static/images/Schematic_freertos_rfid_led_2021-07-06.png)

Si c'est bon nous pouvons d√©buter la partie code.

1. On inclut les en-t√™tes

```C
#include <Arduino.h>
#include <Arduino_FreeRTOS.h> // Need for FreeRTOS with Arduino
#include <SPI.h>              // RFID communicate with Arduino via SPI
#include <MFRC522.h>          // Need to use RFID utilities
```

2. On d√©finit les ports

```C
const uint8_t ss = 10;
const uint8_t rst = 9;
const uint8_t led = A0; // led pin

MFRC522 rfid(ss, rst);
```

3. On d√©finit les prototypes des fonctions: `t√¢ches` et fonctions simples - _(j'en ai l'habitude surtout quand je compte faire des surcharges de fonctions)_

```C
////////////////////////////////////
///////// Task prototype ///////////
////////////////////////////////////
void TaskRfidRead(void *pvParameters);    // task to read rfid
void TaskBlinking(void *pvParameters);    // task to blink led
void TaskSerialPrint(void *pvParameters); // task to print in serial

////////////////////////////////////
/////// Utilities functions ////////
////////////////////////////////////
String getRfidID(byte *buffer, byte bufferSize); // to format and return the rfid id
```

Reamarquez ici que nos t√¢ches ont un prototype bien connu: elles prennent en param√®tre un `pointeur g√©n√©rique` _(peut pointer ensuite sur n'importe quel type de donn√©es)_. Certes
nous n'allons pas l'utiliser mais il reste important ce param√®tre.

4. Le fameux `void setup()`

```C
void setup()
{
  // put your setup code here, to run once:
  Serial.begin(9600);

  SPI.begin();      // Init SPI bus
  rfid.PCD_Init();  // Init MFRC522

  // tasks creation. We can verify if task has been successfully created
  // so we can log some messages

  if (xTaskCreate(TaskRfidRead, "rfid-reader", 128, NULL, 1, NULL) == pdFAIL)
  {
    Serial.println("cannot create task: rfid-reader");
  }

  if (xTaskCreate(TaskBlinking, "blinking", 128, NULL, 1, NULL) == pdFAIL)
  {
    Serial.println("cannot create task: blinking");
  }

  vTaskStartScheduler(); // Start the scheduler so the tasks start executing
}
```

Pour ceux qui avaient lu l'article pr√©c√©dent (celui introduisant les t√¢ches avec Arduino), ils remarqueront un petit
changement lors de la cr√©ation des t√¢ches. Prenons le cas de la cr√©ation de la t√¢che `rfid-reader`:

```C
if (xTaskCreate(TaskRfidRead, "rfid-reader", 128, NULL, 1, NULL) == pdFAIL)
{
  Serial.println("cannot create task: rfid-reader");
}
```

Cette fois ci, si nous v√©rifions si la cr√©ation de la t√¢che s'est d√©roul√©e normalement. `xTaskCreate` renvoie `pdFAIL`
si la t√¢che n'a pas √©t√© cr√©√©e. En plein processus de d√©buggage je pense que cela servirait.
Aussi les deux t√¢ches ont √©t√© cr√©√©es avec le m√™me niveau de priorit√© `(task priority)`: 1. Ceci implique que nous sommes
s√ªr que les deux t√¢ches s'ex√©cuterons en se basant sur le `tick period`.

5. Le `void loop()`, le malheureux reste vide.

```C
void loop()
{
  // put your main code here, to run repeatedly: NOTHING HERE
}
```

6. Imp√©mentation de la t√¢che `rfid-reader`

```C
////////////////////////////////////
///////// Task implementation //////
////////////////////////////////////

// task to read rfid
void TaskRfidRead(void *pvParameters) {
  (void) pvParameters;

  for(;;) {

    if (rfid.PICC_IsNewCardPresent() && rfid.PICC_ReadCardSerial()) {
      String rfidID = getRfidID(rfid.uid.uidByte, rfid.uid.size);

      Serial.print("rfidID: "); Serial.println(rfidID);
    }
  }

}
```

7. Imp√©mentation de la t√¢che `blinking`

```C
// task to blink led
void TaskBlinking(void *pvParameters) {
  (void) pvParameters;

  pinMode(led, OUTPUT);

  for(;;) {
    digitalWrite(led, HIGH);
    vTaskDelay( pdMS_TO_TICKS(200) );
    digitalWrite(led, LOW);
    vTaskDelay( pdMS_TO_TICKS(200) );
  }
}
```

`vTaskDelay` joue le m√™me r√¥le que l'√©ternel `delay` juste que `vTaskDelay` fait passer la t√¢che concern√©e dans le `blocked state`
donc la t√¢che ne s'√©x√©cute plus et il prend en param√®tre le nombre de tick period (expliqu√© dans [l'article pr√©c√©dent](https://tawaldevuniverse.vercel.app/blog/iot/arduino-et-freertos-chapitre1-les-taches)). Et pour cela
on utilise `pdMS_TO_TICKS` qui prend en param√®tre la dur√©e d'attente et retourne le `tick period`.

8. Fonction de formatage des ID des cartes

```C
////////////////////////////////////
/////// Utilities functions ////////
////////////////////////////////////

String getRfidID(byte *buffer, byte bufferSize) {
  String uidRead = "";

  for (byte i = 0; i < bufferSize; i++) {
    uidRead += buffer[i] < 0x10 ? " 0" : " ";
    uidRead += String(buffer[i], HEX);
  }
  uidRead.toUpperCase();

  return uidRead;
}
```

Ex√©cutez le code et admirez le r√©al-time offert par FreeRTOS. Observez correctement les sorties du moniteur et l'allumage de
la led, nous en aurons besoin pour la suite.

#### Conclusion 1:

Quand nous passons une carte, son ID s'affiche plusieurs fois dans le serial monitor
(notre code ne prend pas en charge ce cas). Nous pouvons le contourner (sera fait apr√®s) avec un vTaskDelay. Blinking marche correctement.

## Test 2: RFID-RC522 et Serial Monitor + LED (2 t√¢ches + diff√©rentes priorit√©s)

Alors dans un premier cas nous allons:

1. Augmenter la priorit√© de `rfid-reader`

```C
if (xTaskCreate(TaskRfidRead, "rfid-reader", 128, NULL, 2, NULL) == pdFAIL)
{
  Serial.println("cannot create task: rfid-reader");
}
```

On remarque que la led ne s'allume m√™me plus: la t√¢che `blinking` a une priorit√© inf√©rieure √† celle de `rfid-reader` so elle
reste dans le `blocked state` alors que la premi√®re est dans le `running state`. En r√©alit√© √† chaque `tick interrupt`, le gestionnaire
de t√¢che d√©termine la prochaine t√¢che √† ex√©cuter et comme `rfid-reader` a une priorit√© √©lev√©e _(üòà peut √™tre que Thanos s'appr√™te √† envahir la terre se dit il üòà)_
elle l'ex√©cute √† chaque fois. Ramenez juste la priorit√© de la t√¢che `blinking` √† 2 et vous verrez qu'on aura le m√™me fonctionnement que celui du premier test
(la led s'allume et s'√©teint).

## Test 3: RFID-RC522 et Serial Monitor + LED (2 t√¢ches + diff√©rentes priorit√©s - ajout vTaskDelay √† rfid-reader)

Cette fois ci nous allons ajouter le vTaskDelay √† `rfid-reader` juste apr√®s l'affichage dans le serial (dans le if). Cela emp√™chera les affichages en boucle de la m√™me ID en quelques
secondes mais aussi...√† la t√¢che `blinking` de s'ex√©cuter chaque fois que `rfid-reader` passe dans le `blocked state` car le
gestionnaire de t√¢che en ce moment verra _(qu'est ce qu'il y peut, m√™me les Avengers avaient √©chou√© la premi√®re fois)_ la t√¢che `blinking` en attente.

#### Une remarque: Quand deux t√¢ches sont en attentes d'ex√©cution, celle avec la plus grande priorit√© sera choisie. Si les deux ont le m√™me niveau de priorit√© alors celle ayant attendue le plus sera choisie.

#### Conclusion 2:

L'id√©al _(utopique)_ alors est d'avoir le m√™me niveau de priorit√© pour les t√¢ches ou alors de faire basculer des t√¢ches de priorit√© √©lev√©e
dans le blocked state pour permettre aux t√¢ches de priorit√©s inf√©rieures de s'ex√©cuter ou m√™me de changer de temps en temps la priorit√© des t√¢ches - _(eh oui cela se fait aussi)_ .

## Test 4: RFID-RC522 + Serial Monitor + LED (3 t√¢ches)

Bref ici c'est un exercice pour la prochaine fois:

- Nous devons cr√©er trois t√¢ches: l'une pour receuillir l'ID de la carte, l'autre pour afficher l'ID, et la deni√®re pour le blinking.

Essayez de le r√©aliser, moi je vais pour cela utiliser un autre concept de FreeRTOS. Je ne vous le dit pas, mais la logique est
`de passer l'ID √† la t√¢che qui l'affiche uniquement quand il y a ID`. En lisant l'article introductif sur FreeRTOS vous verrez le mot magique.

# Alors

J'avoue qu'avec ces exemples nous ne remarquons pas vraiment l'importance de FreeRTOS, mais regadez le code:

- Nous ex√©cutons des actions sans pour autant appeler des fonctions les unes apr√®s les autres - _(nous avons acquis notre ind√©pendance)_
- Chaque t√¢che √† l'air de ne pas se `sentir` concern√©e par ce que fait l'autre t√¢che
- Nous pouvons explicitement indiquer l'importance de l'ex√©cution d'une fonction, quand elle peut s'ex√©cuter explicitement sans se soucier de `millis()` ou du retour d'une fonction
  bref les possibilit√©s sont incroyables surtout avec les...

Au passage j'utilise `VSCode + platformIO`(pour ceux que cela interesse). Je vous pr√©pare du lourd pour la prochaine fois. N'h√©sitez pas √† me faire des retours dans mon mail ou sur mon Twitter ou Linkedin dont les r√©f√©rences sont en dessous
ou simplement cliquer sur `Discutons en sur Twitter ‚Ä¢`.

Et sur ce: _can you smell what TawalMc is cooking?_
